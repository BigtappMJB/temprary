package com.codegen.service;

import com.codegen.exception.ServiceException;
import com.codegen.model.GeneratorInput;
import freemarker.template.Template;
import freemarker.template.TemplateException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;
import org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer;

import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

@Slf4j
@Service
public class CodeGenService {

	@Autowired
	private FreeMarkerConfigurer freemarkerConfig;

	@Autowired
	private ReactCodeGenService reactCodeGenService;

	@Autowired
	private DataBaseService databaseService;

	@Autowired
	private JdbcTemplate jdbcTemplate;

	private void writeTemplateToFile(String templateName, Map<String, Object> dataModel, String outputPath)
			throws ServiceException {
		try {
			Template template = freemarkerConfig.getConfiguration().getTemplate(templateName);
			try (FileWriter out = new FileWriter(outputPath)) {
				template.process(dataModel, out);
			}
		} catch (IOException | TemplateException e) {
			throw new ServiceException("Failed to process template: " + templateName, e);
		}
	}

	public void createSpringBootStructure(String basePath, String basePackage) {
		try {
			String baseDir = basePath + "/src/main/java/" + basePackage.replace(".", "/");
			String resourceDir = basePath + "/src/main/resources";

			new File(basePath).mkdirs();
			new File(baseDir + "/controller").mkdirs();
			new File(baseDir + "/service").mkdirs();
			new File(baseDir + "/repository").mkdirs();
			new File(baseDir + "/model").mkdirs();
			new File(resourceDir).mkdirs();
		} catch (Exception e) {
			throw new ServiceException("Failed to create Spring Boot project structure at: " + basePath, e);
		}
	}

	public String generateFullSpringBootApp(GeneratorInput input) {
		long startTime = System.nanoTime();
		try {
			log.info("Starting full Spring Boot application generation for class: {}", input.getClassName());

			String basePath = "generated-app/";
			File baseDir = new File(basePath);
			deleteDirectory(baseDir);

			String fullClassPath = input.getClassName();
			String className = fullClassPath.substring(fullClassPath.lastIndexOf(".") + 1);

			String[] parts = fullClassPath.split("\\.");
			if (parts.length < 2) {
				throw new ServiceException("Invalid class name provided: " + fullClassPath);
			}

			String basePackage = parts[0] + "." + parts[1];
			String packagePath = basePackage.replace(".", "/");

			// File paths
			String javaBasePathController = "C:\\Users\\MohammadJuned\\git\\Rapid_Code_Module\\rapid-code-generator-Backened\\src\\main\\java\\com\\codegen\\controller\\";
			String javaBasePathService = "C:\\Users\\MohammadJuned\\git\\Rapid_Code_Module\\rapid-code-generator-Backened\\src\\main\\java\\com\\codegen\\service\\";
			String javaBasePathRepository = "C:\\Users\\MohammadJuned\\git\\Rapid_Code_Module\\rapid-code-generator-Backened\\src\\main\\java\\com\\codegen\\repository\\";
			String javaBasePathModel = "C:\\Users\\MohammadJuned\\git\\Rapid_Code_Module\\rapid-code-generator-Backened\\src\\main\\java\\com\\codegen\\model\\";
			String resourcesPath = "C:\\Users\\MohammadJuned\\git\\Rapid_Code_Module\\rapid-code-generator-Backened\\src\\main\\resources\\";

			// Create directories
			new File(javaBasePathController).mkdirs();
			new File(javaBasePathService).mkdirs();
			new File(javaBasePathRepository).mkdirs();
			new File(javaBasePathModel).mkdirs();
			new File(resourcesPath).mkdirs();

			// Check for primary key
			List<GeneratorInput.Field> fields = new ArrayList<>(input.getFields());
			boolean hasPrimary = fields.stream().anyMatch(GeneratorInput.Field::isPrimary);
			if (!hasPrimary) {
				GeneratorInput.Field idField = new GeneratorInput.Field("id", "Long", true, "");
				fields.add(0, idField); // Add id as primary key
			}

			// Prepare template model
			Map<String, Object> model = new HashMap<>();
			model.put("className", input.getClassName());
			model.put("fields", fields);
			model.put("package", basePackage);
			model.put("basePackage", basePackage);
			model.put("groupId", "com.codegen");
			model.put("artifactId", className.toLowerCase());
			model.put("masterTable", input.getMasterTable() != null ? input.getMasterTable() : null);
			model.put("relationshipType", input.getRelationshipType() != null ? input.getRelationshipType() : null);


			// Infer relationshipType if not provided and uiType is dropdown
			List<String> generatedFiles = new ArrayList<>();
			if (input.getMasterTable() != null && !input.getMasterTable().isEmpty()) {
				String masterTable = input.getMasterTable().toLowerCase();
				// Infer relationshipType for dropdown
				if (input.getRelationshipType() == null) {
					boolean hasDropdown = fields.stream().anyMatch(f -> "dropdown".equalsIgnoreCase(f.getUiType()));
					if (hasDropdown) {
						model.put("relationshipType", "ManyToOne");
					}
				}
				// Validate master table existence
				List<String> tables = jdbcTemplate.queryForList(
						"SELECT table_name FROM information_schema.tables WHERE table_schema = DATABASE()",
						String.class
				);
				if (!tables.contains(masterTable)) {
					log.warn("Master table '{}' does not exist in the database", masterTable);
					throw new ServiceException("Master table '" + masterTable + "' does not exist in the database");
				}
				// Generate master entity if needed
				String masterEntityFile = javaBasePathModel + capitalize(input.getMasterTable()) + ".java";
				if (!Files.exists(Paths.get(masterEntityFile))) {
					GeneratorInput masterInput = new GeneratorInput();
					masterInput.setClassName("com.codegen.model." + capitalize(input.getMasterTable()));
					masterInput.setFields(fetchColumns(input.getMasterTable()));
					Map<String, Object> masterModel = new HashMap<>();
					masterModel.put("className", masterInput.getClassName());
					masterModel.put("fields", masterInput.getFields());
					masterModel.put("package", basePackage);
					masterModel.put("basePackage", basePackage);
					masterModel.put("groupId", "com.codegen");
					masterModel.put("artifactId", masterTable);
					writeTemplateToFile("Entity.java.ftl", masterModel, masterEntityFile);
					generatedFiles.add(masterEntityFile);
				}
			}

			// Define file paths
			String controllerPath = javaBasePathController + className + "Controller.java";
			String servicePath = javaBasePathService + className + "Service.java";
			String repositoryPath = javaBasePathRepository + className + "Repository.java";
			String modelPath = javaBasePathModel + className + ".java";
			String propertiesPath = resourcesPath + "application.properties";

			// Generate files
			writeTemplateToFile("Controller.java.ftl", model, controllerPath);
			writeTemplateToFile("Service.java.ftl", model, servicePath);
			writeTemplateToFile("Repository.java.ftl", model, repositoryPath);
			writeTemplateToFile("Entity.java.ftl", model, modelPath);
			// writeTemplateToFile("application.properties.ftl", model, propertiesPath); // Uncomment if needed

			generatedFiles.add(modelPath);

			// Generate database script
			String fieldIsPrimary = fields.stream()
					.filter(GeneratorInput.Field::isPrimary)
					.findFirst()
					.map(GeneratorInput.Field::getName)
					.orElse("id");
			databaseService.generateDatabaseScript(basePath, className, fields, fieldIsPrimary);

			// Generate React app
			reactCodeGenService.generateReactApp(basePath + "react/", className, fields, fieldIsPrimary);

			log.info("Successfully generated Spring Boot application for class: {}", input.getClassName());

			return "Spring Boot application generated successfully at " + basePath + "\nGenerated files: " + String.join(", ", generatedFiles);
		} catch (Exception e) {
			log.error("Error generating application for class: {}", input.getClassName(), e);
			throw new ServiceException("Failed to generate full Spring Boot application", e);
		} finally {
			long endTime = System.nanoTime();
			log.info("Total execution time for generateFullSpringBootApp: {} ms", (endTime - startTime) / 1_000_000_000);
		}
	}

	private List<GeneratorInput.Field> fetchColumns(String tableName) {
		try {
			List<Map<String, Object>> columns = jdbcTemplate.queryForList(
					"SELECT c.column_name AS name, c.data_type AS type, " +
							"CASE WHEN k.column_name IS NOT NULL THEN 1 ELSE 0 END AS isPrimary " +
							"FROM information_schema.columns c " +
							"LEFT JOIN information_schema.key_column_usage k " +
							"ON c.table_name = k.table_name AND c.column_name = k.column_name " +
							"AND k.constraint_name = 'PRIMARY' " +
							"WHERE c.table_name = ?",
					tableName
			);
			List<GeneratorInput.Field> fields = new ArrayList<>();
			for (Map<String, Object> col : columns) {
				GeneratorInput.Field field = new GeneratorInput.Field();
				field.setName((String) col.get("name"));
				field.setType(mapDbTypeToJavaType((String) col.get("type")));
				Object isPrimaryValue = col.get("isPrimary");
				boolean isPrimary = isPrimaryValue != null &&
						(isPrimaryValue instanceof Boolean ? (Boolean) isPrimaryValue :
								isPrimaryValue instanceof Number ? ((Number) isPrimaryValue).intValue() == 1 : false);
				field.setPrimary(isPrimary);
				field.setUiType("text"); // Default for master table
				fields.add(field);
			}
			// Ensure at least one primary key
			if (fields.stream().noneMatch(GeneratorInput.Field::isPrimary)) {
				GeneratorInput.Field idField = new GeneratorInput.Field();
				idField.setName("id");
				idField.setType("Long");
				idField.setPrimary(true);
				idField.setUiType("hidden");
				fields.add(0, idField);
			}
			return fields;
		} catch (Exception e) {
			log.error("Failed to fetch columns for table: {}. Query: SELECT c.column_name AS name, c.data_type AS type, " +
					"CASE WHEN k.column_name IS NOT NULL THEN 1 ELSE 0 END AS isPrimary ...", tableName, e);
			throw new ServiceException("Failed to fetch columns for table: " + tableName, e);
		}
	}

	private String mapDbTypeToJavaType(String dbType) {
		switch (dbType.toLowerCase()) {
			case "varchar":
			case "char":
			case "text":
			case "mediumtext":
			case "longtext":
				return "String";
			case "integer":
			case "int":
				return "Integer";
			case "bigint":
				return "Long";
			case "decimal":
			case "numeric":
				return "BigDecimal";
			case "date":
				return "LocalDate";
			case "datetime":
			case "timestamp":
				return "LocalDateTime";
			case "boolean":
			case "tinyint": // MySQL often uses TINYINT for boolean
				return "Boolean";
			default:
				log.warn("Unknown database type: {}, defaulting to String", dbType);
				return "String";
		}
	}

	private String capitalize(String str) {
		if (str == null || str.isEmpty()) return str;
		return str.substring(0, 1).toUpperCase() + str.substring(1).toLowerCase();
	}

	public void deleteDirectory(File directory) {
		if (directory.exists()) {
			File[] files = directory.listFiles();
			if (files != null) {
				for (File file : files) {
					if (file.isDirectory()) {
						deleteDirectory(file);
					} else {
						file.delete();
					}
				}
			}
			directory.delete();
		}
	}

	public String zipGeneratedApp(String sourceDirPath, String zipFilePath) {
		try {
			Path sourceDir = Paths.get(sourceDirPath);
			if (!Files.exists(sourceDir)) {
				throw new ServiceException("Source directory does not exist: " + sourceDirPath);
			}
			log.info("Starting to zip the directory: {}", sourceDirPath);
			log.info("ZIP file will be created at: {}", zipFilePath);
			try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFilePath))) {
				Files.walk(sourceDir)
						.filter(path -> !Files.isDirectory(path))
						.filter(path -> !path.toString().endsWith(".zip"))
						.filter(path -> !path.toString().contains("target"))
						.forEach(path -> {
							try {
								log.info("Processing file: {}", path);
								ZipEntry zipEntry = new ZipEntry(sourceDir.relativize(path).toString());
								zos.putNextEntry(zipEntry);
								Files.copy(path, zos);
								zos.closeEntry();
							} catch (IOException e) {
								log.error("Error while zipping file: {}", path, e);
								throw new ServiceException("Error while zipping file: " + path.getFileName(), e);
							}
						});
			}
			log.info("ZIP file created successfully: {}", zipFilePath);
			return "ZIP file created successfully: " + zipFilePath;
		} catch (IOException e) {
			log.error("Failed to create ZIP file: {}", zipFilePath, e);
			throw new ServiceException("Failed to create ZIP file: " + zipFilePath, e);
		}
	}

	public String buildJar(String projectPath, String jarCommonName) {
		try {
			ProcessBuilder processBuilder = new ProcessBuilder("cmd.exe", "/c",
					"C:\\Users\\MohammadJuned\\Downloads\\apache-maven-3.9.9-bin\\apache-maven-3.9.9\\bin\\mvn.cmd",
					"clean", "package");
			processBuilder.directory(new File(projectPath));
			processBuilder.redirectErrorStream(true);
			processBuilder.inheritIO();
			Process process = processBuilder.start();
			int exitCode = process.waitFor();
			if (exitCode == 0) {
				String jarFilePath = projectPath + "/target/" + jarCommonName + ".jar";
				return "JAR file built successfully! You can find it at: " + projectPath + "/target/";
			} else {
				throw new ServiceException("Maven build failed. Exit code: " + exitCode);
			}
		} catch (IOException | InterruptedException e) {
			throw new ServiceException("Error during JAR build for project path: " + projectPath, e);
		}
	}
}
